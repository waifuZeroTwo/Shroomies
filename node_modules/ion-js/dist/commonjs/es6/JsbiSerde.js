"use strict";
/*!
 * Copyright 2012 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * A copy of the License is located at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing
 * permissions and limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsbiSerde = void 0;
const jsbi_1 = __importDefault(require("jsbi"));
const JsbiSupport_1 = require("./JsbiSupport");
class JsbiSerde {
    static toSignedIntBytes(value, isNegative) {
        let bytes = this.toUnsignedIntBytes(value);
        if (bytes[0] >= 128) {
            const extendedBytes = new Uint8Array(bytes.length + 1);
            extendedBytes.set(bytes, 1);
            bytes = extendedBytes;
        }
        if (isNegative) {
            bytes[0] += 0x80;
        }
        return bytes;
    }
    static fromUnsignedBytes(bytes) {
        let magnitude = JsbiSupport_1.JsbiSupport.ZERO;
        for (let m = 0; m < bytes.length; m++) {
            const byte = jsbi_1.default.BigInt(bytes[m]);
            magnitude = jsbi_1.default.leftShift(magnitude, this.BITS_PER_BYTE);
            magnitude = jsbi_1.default.bitwiseOr(magnitude, byte);
        }
        return magnitude;
    }
    static toUnsignedIntBytes(value) {
        if (JsbiSupport_1.JsbiSupport.isNegative(value)) {
            value = jsbi_1.default.unaryMinus(value);
        }
        const sizeInBytes = this.getUnsignedIntSizeInBytes(value);
        const bytes = new Uint8Array(sizeInBytes);
        for (let m = sizeInBytes - 1; m >= 0; m--) {
            const lastByte = jsbi_1.default.toNumber(jsbi_1.default.bitwiseAnd(value, this.BYTE_MAX_VALUE));
            value = jsbi_1.default.signedRightShift(value, this.BITS_PER_BYTE);
            bytes[m] = lastByte;
        }
        return bytes;
    }
    static getUnsignedIntSizeInBytes(value) {
        for (let m = 0; m < this.SIZE_THRESHOLDS.length; m++) {
            const threshold = this.SIZE_THRESHOLDS[m];
            if (jsbi_1.default.lessThanOrEqual(value, threshold)) {
                return m + 1;
            }
        }
        let sizeInBytes = this.SIZE_THRESHOLDS.length;
        let threshold = this.calculateSizeThreshold(sizeInBytes);
        while (jsbi_1.default.greaterThan(value, threshold)) {
            sizeInBytes++;
            threshold = this.calculateSizeThreshold(sizeInBytes);
        }
        return sizeInBytes;
    }
    static calculateSizeThresholds() {
        const thresholds = [];
        for (let m = 1; m <= this.SERIALIZED_JSBI_SIZES_TO_PRECOMPUTE; m++) {
            thresholds.push(this.calculateSizeThreshold(m));
        }
        return thresholds;
    }
    static calculateSizeThreshold(numberOfBytes) {
        const exponent = jsbi_1.default.multiply(jsbi_1.default.BigInt(numberOfBytes), this.BITS_PER_BYTE);
        const threshold = jsbi_1.default.exponentiate(JsbiSupport_1.JsbiSupport.TWO, exponent);
        return jsbi_1.default.subtract(threshold, JsbiSupport_1.JsbiSupport.ONE);
    }
}
exports.JsbiSerde = JsbiSerde;
JsbiSerde.SERIALIZED_JSBI_SIZES_TO_PRECOMPUTE = 64;
JsbiSerde.BITS_PER_BYTE = jsbi_1.default.BigInt(8);
JsbiSerde.BYTE_MAX_VALUE = jsbi_1.default.BigInt(0xff);
JsbiSerde.SIZE_THRESHOLDS = JsbiSerde.calculateSizeThresholds();
//# sourceMappingURL=JsbiSerde.js.map