"use strict";
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = void 0;
const ion_js_1 = require("ion-js");
const semaphore_async_await_1 = require("semaphore-async-await");
const Errors_1 = require("./errors/Errors");
const QldbHash_1 = require("./QldbHash");
const Result_1 = require("./Result");
const ResultReadable_1 = require("./ResultReadable");
/**
 * A class representing a QLDB transaction.
 *
 * Every transaction is tied to a parent QldbSession, meaning that if the parent session is closed or invalidated, the
 * child transaction is automatically closed and cannot be used. Only one transaction can be active at any given time
 * per parent session.
 *
 * Any unexpected errors that occur within a transaction should not be retried using the same transaction, as the state
 * of the transaction is now ambiguous.
 *
 * When an OCC conflict occurs, the transaction is closed and must be handled manually by creating a new transaction
 * and re-executing the desired statements.
 *
 * @internal
 */
class Transaction {
    /**
     * Create a Transaction.
     * @param communicator The Communicator object representing a communication channel with QLDB.
     * @param txnId The ID of the transaction.
     */
    constructor(communicator, txnId) {
        this._communicator = communicator;
        this._txnId = txnId;
        this._txnHash = QldbHash_1.QldbHash.toQldbHash(txnId);
        this._hashLock = new semaphore_async_await_1.Lock();
    }
    /**
     * Commits and closes child ResultReadable objects.
     * @returns Promise which fulfills with void.
     * @throws {@linkcode ClientException} when the commit digest from commit transaction result does not match.
     */
    commit() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._hashLock.acquire();
            try {
                const commitTxnResult = yield this._communicator.commit({
                    TransactionId: this._txnId,
                    CommitDigest: this._txnHash.getQldbHash()
                });
                if ((0, ion_js_1.toBase64)(this._txnHash.getQldbHash()) !== (0, ion_js_1.toBase64)((commitTxnResult.CommitDigest))) {
                    throw new Errors_1.ClientError(`Transaction's commit digest did not match returned value from QLDB.
                    Please retry with a new transaction. Transaction ID: ${this._txnId}.`);
                }
            }
            finally {
                this._hashLock.release();
            }
        });
    }
    /**
     * Execute the specified statement in the current transaction. This method returns a promise
     * which eventually returns all the results loaded into memory.
     *
     * @param statement A statement to execute against QLDB as a string.
     * @param parameters Variable number of arguments, where each argument corresponds to a
     *                  placeholder (?) in the PartiQL query.
     *                  The argument could be any native JavaScript type or an Ion DOM type.
     *                  [Details of Ion DOM type and JavaScript type](https://github.com/amzn/ion-js/blob/master/src/dom/README.md#iondom-data-types)
     * @returns Promise which fulfills with all results loaded into memory
     * @throws [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) when the passed argument value cannot be converted into Ion
     */
    execute(statement, ...parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this._sendExecute(statement, parameters);
            return Result_1.Result.create(this._txnId, result, this._communicator);
        });
    }
    /**
     * Execute the specified statement in the current transaction. This method returns a promise
     * which fulfills with Readable Stream, which allows you to stream one record at time
     *
     * @param statement A statement to execute against QLDB as a string.
     * @param parameters Variable number of arguments, where each argument corresponds to a
     *                  placeholder (?) in the PartiQL query.
     *                  The argument could be any native JavaScript type or an Ion DOM type.
     *                  [Details of Ion DOM type and JavaScript type](https://github.com/amzn/ion-js/blob/master/src/dom/README.md#iondom-data-types)
     * @returns Promise which fulfills with a Readable Stream
     * @throws {@linkcode TransactionClosedError} when the transaction is closed.
     * @throws [Error](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error) when the passed argument value cannot be converted into Ion
     */
    executeAndStreamResults(statement, ...parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this._sendExecute(statement, parameters);
            return new ResultReadable_1.ResultReadable(this._txnId, result, this._communicator);
        });
    }
    /**
     * Retrieve the transaction ID associated with this transaction.
     * @returns The transaction ID.
     */
    getTransactionId() {
        return this._txnId;
    }
    /**
     * Helper method to execute statement against QLDB.
     * @param statement A statement to execute against QLDB as a string.
     * @param parameters An optional list of Ion values or JavaScript native types that are convertible to Ion for
     *                   filling in parameters of the statement.
     * @returns Promise which fulfills with a ExecuteStatementResult object.
     */
    _sendExecute(statement, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._hashLock.acquire();
            try {
                let statementHash = QldbHash_1.QldbHash.toQldbHash(statement);
                const valueHolderList = parameters.map((param) => {
                    let ionBinary;
                    try {
                        ionBinary = (0, ion_js_1.dumpBinary)(param);
                    }
                    catch (e) {
                        e.message = `Failed to convert parameter ${String(param)} to Ion Binary: ${e.message}`;
                        throw e;
                    }
                    statementHash = statementHash.dot(QldbHash_1.QldbHash.toQldbHash(ionBinary));
                    const valueHolder = {
                        IonBinary: ionBinary
                    };
                    return valueHolder;
                });
                this._txnHash = this._txnHash.dot(statementHash);
                const result = yield this._communicator.executeStatement(this._txnId, statement, valueHolderList);
                return result;
            }
            finally {
                this._hashLock.release();
            }
        });
    }
}
exports.Transaction = Transaction;
