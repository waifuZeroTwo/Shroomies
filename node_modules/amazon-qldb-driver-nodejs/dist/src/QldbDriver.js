"use strict";
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QldbDriver = void 0;
const client_qldb_session_1 = require("@aws-sdk/client-qldb-session");
const http_1 = require("http");
const semaphore_async_await_1 = require("semaphore-async-await");
const package_json_1 = require("../package.json");
const Communicator_1 = require("./Communicator");
const Errors_1 = require("./errors/Errors");
const LogUtil_1 = require("./LogUtil");
const QldbSession_1 = require("./QldbSession");
const DefaultRetryConfig_1 = require("./retry/DefaultRetryConfig");
const node_http_handler_1 = require("@aws-sdk/node-http-handler");
/**
  * This is the entry point for all interactions with Amazon QLDB.
  *
  * In order to start using the driver, you need to instantiate it with a ledger name:
  *
  * ```
  * let qldbDriver: QldbDriver = new QldbDriver(your-ledger-name);
  * ```
  * You can pass more parameters to the constructor of the driver which allow you to control certain limits
  * to improve the performance. Check the {@link QldbDriver.constructor} to see all the available parameters.
  *
  * A single instance of the QldbDriver is attached to only one ledger. All transactions will be executed against
  * the ledger specified.
  *
  * The driver exposes {@link QldbDriver.executeLambda}  method which should be used to execute the transactions.
  * Check the {@link QldbDriver.executeLambda} method for more details on how to execute the Transaction.
 */
class QldbDriver {
    /**
     * Creates a QldbDriver instance that can be used to execute transactions against Amazon QLDB. A single instance of the QldbDriver
     * is always attached to one ledger, as specified in the ledgerName parameter.
     *
     * @param ledgerName The name of the ledger you want to connect to. This is a mandatory parameter.
     * @param qldbClientOptions The object containing options for configuring the low level client.
     *                          See {@link https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-qldb-session/classes/qldbsessionclient.html#constructor}.
     * @param httpOptions The object containing options for configuring the low level http request handler for qldb session client.
     *                    See {@link https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-qldb-session/interfaces/nodehttphandleroptions.html}
     * @param maxConcurrentTransactions The driver internally uses a pool of sessions to execute the transactions.
     *                                  The maxConcurrentTransactions parameter specifies the number of sessions that the driver can hold in the pool.
     *                                  The default is set to maximum number of sockets specified for the `httpAgent` in `httpOptions`. If `httpAgent` is not defined,
     *                                  the default of `maxConcurrentTransactions` takes the `maxSockets` value from the `globalAgent`.
     *                                  See {@link https://docs.aws.amazon.com/qldb/latest/developerguide/driver.best-practices.html#driver.best-practices.configuring} for more details.
     * @param retryConfig Config to specify max number of retries, base and custom backoff strategy for retries. Will be overridden if a different retryConfig
     *                    is passed to {@linkcode executeLambda}.
     *
     * @throws RangeError if `maxConcurrentTransactions` is less than 0 or more than `maxSockets` set by `httpAgent` or `globalAgent`.
     */
    constructor(ledgerName, qldbClientOptions = {}, httpOptions = {}, maxConcurrentTransactions = 0, retryConfig = DefaultRetryConfig_1.defaultRetryConfig) {
        qldbClientOptions.customUserAgent = `QLDB Driver for Node.js v${package_json_1.version}`;
        qldbClientOptions.maxAttempts = 0;
        qldbClientOptions.requestHandler = new node_http_handler_1.NodeHttpHandler(httpOptions);
        this._qldbClient = new client_qldb_session_1.QLDBSession(qldbClientOptions);
        this._ledgerName = ledgerName;
        this._isClosed = false;
        this._retryConfig = retryConfig;
        if (maxConcurrentTransactions < 0) {
            throw new RangeError("Value for maxConcurrentTransactions cannot be negative.");
        }
        let maxSockets;
        if (httpOptions.httpAgent) {
            maxSockets = httpOptions.httpAgent.maxSockets;
        }
        else if (httpOptions.httpsAgent) {
            maxSockets = httpOptions.httpsAgent.maxSockets;
        }
        else {
            maxSockets = http_1.globalAgent.maxSockets;
        }
        if (0 === maxConcurrentTransactions) {
            this._maxConcurrentTransactions = maxSockets;
        }
        else {
            this._maxConcurrentTransactions = maxConcurrentTransactions;
        }
        if (this._maxConcurrentTransactions > maxSockets) {
            throw new RangeError(`The session pool limit given, ${this._maxConcurrentTransactions}, exceeds the limit set by the client,
                 ${maxSockets}. Please lower the limit and retry.`);
        }
        this._sessionPool = [];
        this._semaphore = new semaphore_async_await_1.default(this._maxConcurrentTransactions);
    }
    /**
     * This is a driver shutdown method which closes all the sessions and marks the driver as closed.
     * Once the driver is closed, no transactions can be executed on that driver instance.
     *
     * Note: There is no corresponding `open` method and the only option is to instantiate another driver.
     */
    close() {
        this._isClosed = true;
        while (this._sessionPool.length > 0) {
            const session = this._sessionPool.pop();
            if (session != undefined) {
                session.endSession();
            }
        }
    }
    /**
     * This is the primary method to execute a transaction against Amazon QLDB ledger.
     *
     * When this method is invoked, the driver will acquire a `Transaction` and hand it to the `TransactionExecutor` you
     * passed via the `transactionFunction` parameter. Once the `transactionFunction`'s execution is done, the driver will try to
     * commit the transaction.
     * If there is a failure along the way, the driver will retry the entire transaction block. This would mean that your code inside the
     * `transactionFunction` function should be idempotent.
     *
     * You can also return the results from the `transactionFunction`. Here is an example code of executing a transaction
     *
     * ```
     * let result = driver.executeLambda(async (txn:TransactionExecutor) => {
     *   let a = await txn.execute("SELECT a from Table1");
     *   let b = await txn.execute("SELECT b from Table2");
     *   return {a: a, b: b};
     * });
     *```
     *
     * Please keep in mind that the entire transaction will be committed once all the code inside the `transactionFunction` is executed.
     * So for the above example the values inside the  transactionFunction, a and b, are speculative values. If the commit of the transaction fails,
     * the entire `transactionFunction` will be retried.
     *
     * The function passed via retryIndicator parameter is invoked whenever there is a failure and the driver is about to retry the transaction.
     * The retryIndicator will be called with the current attempt number.
     *
     * @param transactionLambda The function representing a transaction to be executed. Please see the method docs to understand the usage of this parameter.
     * @param retryConfig Config to specify max number of retries, base and custom backoff strategy for retries. This config
     *                    overrides the retry config set at driver level for a particular lambda execution.
     *                    Note that all the values of the driver level retry config will be overridden by the new config passed here.
     * @throws {@linkcode DriverClosedError} When a transaction is attempted on a closed driver instance. {@linkcode close}
     * @throws {@linkcode ClientException} When the commit digest from commit transaction result does not match.
     * @throws {@linkcode SessionPoolEmptyError} When maxConcurrentTransactions limit is reached and there is no session available in the pool.
     * @throws {@linkcode InvalidSessionException} When a session expires either due to a long-running transaction or session being idle for long time.
     * @throws {@linkcode BadRequestException} When Amazon QLDB is not able to execute a query or transaction.
     */
    executeLambda(transactionLambda, retryConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._isClosed) {
                throw new Errors_1.DriverClosedError();
            }
            retryConfig = (retryConfig == null) ? this._retryConfig : retryConfig;
            let replaceDeadSession = false;
            for (let retryAttempt = 1; true; retryAttempt++) {
                let session = null;
                try {
                    if (replaceDeadSession) {
                        session = yield this.createNewSession(this);
                    }
                    else {
                        session = yield this.getSession(this);
                    }
                    return yield session.executeLambda(transactionLambda);
                }
                catch (e) {
                    if (e instanceof Errors_1.ExecuteError) {
                        if (e.isRetryable) {
                            // Always retry on the first attempt if failure was caused by a stale session in the pool 
                            if (retryAttempt == 1 && e.isInvalidSessionException) {
                                (0, LogUtil_1.debug)("Initial session received from pool is invalid. Retrying...");
                                continue;
                            }
                            if (retryAttempt > retryConfig.getRetryLimit()) {
                                throw e.cause;
                            }
                            const backoffFunction = retryConfig.getBackoffFunction();
                            let backoffDelay = backoffFunction(retryAttempt, e.cause, e.transactionId);
                            if (backoffDelay == null || backoffDelay < 0) {
                                backoffDelay = 0;
                            }
                            yield new Promise(resolve => setTimeout(resolve, backoffDelay));
                            (0, LogUtil_1.info)(`A recoverable error has occurred. Attempting retry #${retryAttempt}.`);
                            (0, LogUtil_1.debug)(`Error cause: ${e.cause}`);
                            continue;
                        }
                        else {
                            throw e.cause;
                        }
                    }
                    else {
                        throw e;
                    }
                }
                finally {
                    replaceDeadSession = !this.releaseSession(this, session);
                }
            }
        });
    }
    // Release semaphore and if the session is alive return it to the pool and return true
    releaseSession(thisDriver, session) {
        if (session != null && session.isAlive()) {
            thisDriver._sessionPool.push(session);
            thisDriver._semaphore.release();
            (0, LogUtil_1.debug)(`Session returned to pool; pool size is now: ${thisDriver._sessionPool.length}`);
            return true;
        }
        else if (session != null) {
            thisDriver._semaphore.release();
            return false;
        }
        else {
            return false;
        }
    }
    // Acquire semaphore and get a session from the pool
    getSession(thisDriver) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, LogUtil_1.debug)(`Getting session. Current free session count: ${thisDriver._sessionPool.length}. ` +
                `Currently available permit count: ${thisDriver._semaphore.getPermits()}.`);
            if (thisDriver._semaphore.tryAcquire()) {
                let session = thisDriver._sessionPool.pop();
                if (session == undefined) {
                    (0, LogUtil_1.debug)(`Creating a new pooled session.`);
                    session = yield this.createNewSession(thisDriver);
                }
                return session;
            }
            else {
                throw new Errors_1.SessionPoolEmptyError();
            }
        });
    }
    createNewSession(thisDriver) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const communicator = yield Communicator_1.Communicator.create(thisDriver._qldbClient, thisDriver._ledgerName);
                return new QldbSession_1.QldbSession(communicator);
            }
            catch (e) {
                // An error when failing to start a new session is always retryable
                throw new Errors_1.ExecuteError(e, true, true);
            }
        });
    }
    /**
     * A helper method to get all the table names in a ledger.
     * @returns Promise which fulfills with an array of table names.
     */
    getTableNames() {
        return __awaiter(this, void 0, void 0, function* () {
            const statement = "SELECT name FROM information_schema.user_tables WHERE status = 'ACTIVE'";
            return yield this.executeLambda((transactionExecutor) => __awaiter(this, void 0, void 0, function* () {
                const result = yield transactionExecutor.execute(statement);
                const resultStructs = result.getResultList();
                return resultStructs.map(tableNameStruct => tableNameStruct.get("name").stringValue());
            }));
        });
    }
}
exports.QldbDriver = QldbDriver;
