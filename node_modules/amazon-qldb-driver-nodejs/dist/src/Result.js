"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Result = void 0;
const ion_js_1 = require("ion-js");
const Errors_1 = require("./errors/Errors");
const IOUsage_1 = require("./stats/IOUsage");
const TimingInformation_1 = require("./stats/TimingInformation");
/**
 * A class representing a fully buffered set of results returned from QLDB.
 */
class Result {
    /**
     * Creates a Result.
     * @param resultList A list of Ion values containing the statement execution's result returned from QLDB.
     * @param ioUsage Contains the number of consumed IO requests for the executed statement.
     * @param timingInformation Holds server side processing time for the executed statement.
     */
    constructor(resultList, ioUsage, timingInformation) {
        this._resultList = resultList;
        this._ioUsage = ioUsage;
        this._timingInformation = timingInformation;
    }
    /**
     * Static factory method that creates a Result object, containing the results of a statement execution from QLDB.
     * @param txnId The ID of the transaction the statement was executed in.
     * @param executeResult The returned result from the statement execution.
     * @param communicator The Communicator used for the statement execution.
     * @returns Promise which fulfills with a Result.
     *
     * @internal
     */
    static create(txnId, executeResult, communicator) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield Result._fetchResultPages(txnId, executeResult, communicator);
            return result;
        });
    }
    /**
     * Static method that creates a Result object by reading and buffering the contents of a ResultReadable.
     * @param resultReadable A ResultReadable object to convert to a Result object.
     * @returns Promise which fulfills with a Result.
     */
    static bufferResultReadable(resultReadable) {
        return __awaiter(this, void 0, void 0, function* () {
            const resultList = yield Result._readResultReadable(resultReadable);
            return new Result(resultList, resultReadable.getConsumedIOs(), resultReadable.getTimingInformation());
        });
    }
    /**
     * Returns the list of results of the statement execution returned from QLDB.
     * @returns A list of Ion values which wrap the Ion values returned from the QLDB statement execution.
     */
    getResultList() {
        return this._resultList.slice();
    }
    /**
     * Returns the number of read IO request for the executed statement.
     * @returns IOUsage, containing number of read IOs.
     */
    getConsumedIOs() {
        return this._ioUsage;
    }
    /**
     * Returns server-side processing time for the executed statement.
     * @returns TimingInformation, containing processing time.
     */
    getTimingInformation() {
        return this._timingInformation;
    }
    /**
     * Handle the unexpected Blob return type from QLDB.
     * @param ionBinary The IonBinary value returned from QLDB.
     * @returns The IonBinary value cast explicitly to one of the types that make up the IonBinary type. This will be
     *          either Buffer, Uint8Array, or string.
     * @throws {@linkcode ClientException} when the specific type of the IonBinary value is Blob.
     *
     * @internal
     */
    static _handleBlob(ionBinary) {
        if (ionBinary instanceof Buffer) {
            return ionBinary;
        }
        if (ionBinary instanceof Uint8Array) {
            return ionBinary;
        }
        if (typeof ionBinary === "string") {
            return ionBinary;
        }
        throw new Errors_1.ClientError("Unexpected Blob returned from QLDB.");
    }
    /**
     * Fetches all subsequent Pages given an initial Page, places each value of each Page in an Ion value.
     * @param txnId The ID of the transaction the statement was executed in.
     * @param executeResult The returned result from the statement execution.
     * @param communicator The Communicator used for the statement execution.
     * @returns Promise which fulfills with a Result, containing a list of Ion values, representing all the returned
     * values of the result set, number of IOs for the request, and the time spent processing the request.
     */
    static _fetchResultPages(txnId, executeResult, communicator) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentPage = executeResult.FirstPage;
            let readIO = executeResult.ConsumedIOs != null ? executeResult.ConsumedIOs.ReadIOs : null;
            let processingTime = executeResult.TimingInformation != null ? executeResult.TimingInformation.ProcessingTimeMilliseconds : null;
            const pageValuesArray = [];
            if (currentPage.Values && currentPage.Values.length > 0) {
                pageValuesArray.push(currentPage.Values);
            }
            while (currentPage.NextPageToken) {
                const fetchPageResult = yield communicator.fetchPage(txnId, currentPage.NextPageToken);
                currentPage = fetchPageResult.Page;
                if (currentPage.Values && currentPage.Values.length > 0) {
                    pageValuesArray.push(currentPage.Values);
                }
                if (fetchPageResult.ConsumedIOs != null) {
                    readIO += fetchPageResult.ConsumedIOs.ReadIOs;
                }
                if (fetchPageResult.TimingInformation != null) {
                    processingTime += fetchPageResult.TimingInformation.ProcessingTimeMilliseconds;
                }
            }
            const ionValues = [];
            pageValuesArray.forEach((valueHolders) => {
                valueHolders.forEach((valueHolder) => {
                    ionValues.push(ion_js_1.dom.load(Result._handleBlob(valueHolder.IonBinary)));
                });
            });
            const ioUsage = readIO != null ? new IOUsage_1.IOUsage(readIO) : null;
            const timingInformation = processingTime != null ? new TimingInformation_1.TimingInformation(processingTime) : null;
            return new Result(ionValues, ioUsage, timingInformation);
        });
    }
    /**
     * Helper method that reads a ResultReadable and extracts the results, placing them in an array of Ion values.
     * @param resultReadable The ResultReadable to read.
     * @returns Promise which fulfills with a list of Ion values, representing all the returned values of the result set.
     */
    static _readResultReadable(resultReadable) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise(res => {
                const ionValues = [];
                resultReadable.on("data", function (value) {
                    ionValues.push(value);
                }).on("end", function () {
                    res(ionValues);
                });
            });
        });
    }
}
exports.Result = Result;
