import { QLDBSessionClientConfig } from "@aws-sdk/client-qldb-session";
import { RetryConfig } from "./retry/RetryConfig";
import { TransactionExecutor } from "./TransactionExecutor";
import { NodeHttpHandlerOptions } from "@aws-sdk/node-http-handler";
/**
  * This is the entry point for all interactions with Amazon QLDB.
  *
  * In order to start using the driver, you need to instantiate it with a ledger name:
  *
  * ```
  * let qldbDriver: QldbDriver = new QldbDriver(your-ledger-name);
  * ```
  * You can pass more parameters to the constructor of the driver which allow you to control certain limits
  * to improve the performance. Check the {@link QldbDriver.constructor} to see all the available parameters.
  *
  * A single instance of the QldbDriver is attached to only one ledger. All transactions will be executed against
  * the ledger specified.
  *
  * The driver exposes {@link QldbDriver.executeLambda}  method which should be used to execute the transactions.
  * Check the {@link QldbDriver.executeLambda} method for more details on how to execute the Transaction.
 */
export declare class QldbDriver {
    private _maxConcurrentTransactions;
    private _sessionPool;
    private _semaphore;
    private _qldbClient;
    private _ledgerName;
    private _isClosed;
    private _retryConfig;
    /**
     * Creates a QldbDriver instance that can be used to execute transactions against Amazon QLDB. A single instance of the QldbDriver
     * is always attached to one ledger, as specified in the ledgerName parameter.
     *
     * @param ledgerName The name of the ledger you want to connect to. This is a mandatory parameter.
     * @param qldbClientOptions The object containing options for configuring the low level client.
     *                          See {@link https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-qldb-session/classes/qldbsessionclient.html#constructor}.
     * @param httpOptions The object containing options for configuring the low level http request handler for qldb session client.
     *                    See {@link https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-qldb-session/interfaces/nodehttphandleroptions.html}
     * @param maxConcurrentTransactions The driver internally uses a pool of sessions to execute the transactions.
     *                                  The maxConcurrentTransactions parameter specifies the number of sessions that the driver can hold in the pool.
     *                                  The default is set to maximum number of sockets specified for the `httpAgent` in `httpOptions`. If `httpAgent` is not defined,
     *                                  the default of `maxConcurrentTransactions` takes the `maxSockets` value from the `globalAgent`.
     *                                  See {@link https://docs.aws.amazon.com/qldb/latest/developerguide/driver.best-practices.html#driver.best-practices.configuring} for more details.
     * @param retryConfig Config to specify max number of retries, base and custom backoff strategy for retries. Will be overridden if a different retryConfig
     *                    is passed to {@linkcode executeLambda}.
     *
     * @throws RangeError if `maxConcurrentTransactions` is less than 0 or more than `maxSockets` set by `httpAgent` or `globalAgent`.
     */
    constructor(ledgerName: string, qldbClientOptions?: QLDBSessionClientConfig, httpOptions?: NodeHttpHandlerOptions, maxConcurrentTransactions?: number, retryConfig?: RetryConfig);
    /**
     * This is a driver shutdown method which closes all the sessions and marks the driver as closed.
     * Once the driver is closed, no transactions can be executed on that driver instance.
     *
     * Note: There is no corresponding `open` method and the only option is to instantiate another driver.
     */
    close(): void;
    /**
     * This is the primary method to execute a transaction against Amazon QLDB ledger.
     *
     * When this method is invoked, the driver will acquire a `Transaction` and hand it to the `TransactionExecutor` you
     * passed via the `transactionFunction` parameter. Once the `transactionFunction`'s execution is done, the driver will try to
     * commit the transaction.
     * If there is a failure along the way, the driver will retry the entire transaction block. This would mean that your code inside the
     * `transactionFunction` function should be idempotent.
     *
     * You can also return the results from the `transactionFunction`. Here is an example code of executing a transaction
     *
     * ```
     * let result = driver.executeLambda(async (txn:TransactionExecutor) => {
     *   let a = await txn.execute("SELECT a from Table1");
     *   let b = await txn.execute("SELECT b from Table2");
     *   return {a: a, b: b};
     * });
     *```
     *
     * Please keep in mind that the entire transaction will be committed once all the code inside the `transactionFunction` is executed.
     * So for the above example the values inside the  transactionFunction, a and b, are speculative values. If the commit of the transaction fails,
     * the entire `transactionFunction` will be retried.
     *
     * The function passed via retryIndicator parameter is invoked whenever there is a failure and the driver is about to retry the transaction.
     * The retryIndicator will be called with the current attempt number.
     *
     * @param transactionLambda The function representing a transaction to be executed. Please see the method docs to understand the usage of this parameter.
     * @param retryConfig Config to specify max number of retries, base and custom backoff strategy for retries. This config
     *                    overrides the retry config set at driver level for a particular lambda execution.
     *                    Note that all the values of the driver level retry config will be overridden by the new config passed here.
     * @throws {@linkcode DriverClosedError} When a transaction is attempted on a closed driver instance. {@linkcode close}
     * @throws {@linkcode ClientException} When the commit digest from commit transaction result does not match.
     * @throws {@linkcode SessionPoolEmptyError} When maxConcurrentTransactions limit is reached and there is no session available in the pool.
     * @throws {@linkcode InvalidSessionException} When a session expires either due to a long-running transaction or session being idle for long time.
     * @throws {@linkcode BadRequestException} When Amazon QLDB is not able to execute a query or transaction.
     */
    executeLambda<T>(transactionLambda: (transactionExecutor: TransactionExecutor) => Promise<T>, retryConfig?: RetryConfig): Promise<T>;
    private releaseSession;
    private getSession;
    private createNewSession;
    /**
     * A helper method to get all the table names in a ledger.
     * @returns Promise which fulfills with an array of table names.
     */
    getTableNames(): Promise<string[]>;
}
