"use strict";
/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file except in compliance with
 * the License. A copy of the License is located at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions
 * and limitations under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QldbSession = void 0;
const Errors_1 = require("./errors/Errors");
const LogUtil_1 = require("./LogUtil");
const Transaction_1 = require("./Transaction");
const TransactionExecutor_1 = require("./TransactionExecutor");
/**
 * @internal
 */
class QldbSession {
    constructor(communicator) {
        this._communicator = communicator;
        this._isAlive = true;
    }
    isAlive() {
        return this._isAlive;
    }
    endSession() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this._isAlive = false;
                yield this._communicator.endSession();
            }
            catch (e) {
                // We will only log issues ending the session, as QLDB will clean them after a timeout.
                (0, LogUtil_1.warn)(`Errors ending session: ${e}.`);
            }
        });
    }
    executeLambda(transactionLambda) {
        return __awaiter(this, void 0, void 0, function* () {
            let transaction;
            let transactionId = null;
            let onCommit = false;
            try {
                transaction = yield this._startTransaction();
                transactionId = transaction.getTransactionId();
                const executor = new TransactionExecutor_1.TransactionExecutor(transaction);
                const returnedValue = yield transactionLambda(executor);
                onCommit = true;
                yield transaction.commit();
                return returnedValue;
            }
            catch (e) {
                const isRetryable = (0, Errors_1.isRetryableException)(e, onCommit);
                const isISE = (0, Errors_1.isInvalidSessionException)(e);
                if (isISE && !(0, Errors_1.isTransactionExpiredException)(e)) {
                    // Underlying session is dead on InvalidSessionException except for transaction expiry
                    this._isAlive = false;
                }
                else if (!(0, Errors_1.isOccConflictException)(e)) {
                    // OCC does not need session state reset as the transaction is implicitly closed
                    yield this._cleanSessionState();
                }
                throw new Errors_1.ExecuteError(e, isRetryable, isISE, transactionId);
            }
        });
    }
    _startTransaction() {
        return __awaiter(this, void 0, void 0, function* () {
            const startTransactionResult = yield this._communicator.startTransaction();
            return new Transaction_1.Transaction(this._communicator, startTransactionResult.TransactionId);
        });
    }
    _cleanSessionState() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this._communicator.abortTransaction();
            }
            catch (e) {
                (0, LogUtil_1.warn)(`Ignored error while aborting transaction during execution: ${e}.`);
                this._isAlive = false;
            }
        });
    }
}
exports.QldbSession = QldbSession;
